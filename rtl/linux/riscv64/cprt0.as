/* Startup code for ARM & ELF
   Copyright (C) 1995, 1996, 1997, 1998, 2001, 2002 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with the GNU C Library; if not, write to the Free
   Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
   MA 02110-1301, USA. */

/* This is the canonical entry point, usually the first thing in the text
   segment.

        Note that the code in the .init section has already been run.
        This includes _init and _libc_init


        At this entry point, most registers' values are unspecified, except:

   a0           Contains a function pointer to be registered with `atexit'.
                This is how the dynamic linker arranges to have DT_FINI
                functions called for shared libraries that have been loaded
                before this code runs.

   sp           The stack contains the arguments and environment:
                0(sp)                   argc
                8(sp)                   argv[0]
                ...
                (8*argc)(sp)            NULL
                (8*(argc+1))(sp)        envp[0]
                ...
                                        NULL
*/

        .text
        .globl _start
        .type _start,function
_start:
        .option push
        .option norelax
1:auipc gp, %pcrel_hi(__global_pointer$)
        addi  gp, gp, %pcrel_lo(1b)
        .option pop

        /* Store rtld_fini in a5 */
        addi a5, a0, 0

        /* Clear the frame pointer since this is the outermost frame.  */
        addi x8, x0, 0

        /* Pop argc off the stack, and save argc, argv and envp */
        ld   a1, 0(sp)
        addi a2, sp, 8
        addi a4, a1, 1
        slli a4, a4, 3
        add  a4, a2, a4

1:auipc	x8,%pcrel_hi(operatingsystem_parameter_argc)
	sw	a1,%pcrel_lo(1b)(x8)
1:auipc	x8,%pcrel_hi(operatingsystem_parameter_argv)
	sd	a2,%pcrel_lo(1b)(x8)
1:auipc	x8,%pcrel_hi(operatingsystem_parameter_envp)
	sd	a4,%pcrel_lo(1b)(x8)

        /* Save initial stackpointer */
1:auipc	x8,%pcrel_hi(__stkptr)
	sd	sp,%pcrel_lo(1b)(x8)

        /* Fetch address of fini */
1:auipc	x8,%pcrel_hi(__libc_csu_fini)
	addi	a4,x8,%pcrel_lo(1b)

        addi a6, sp, 0

        /* Set up the other arguments in registers */
1:auipc	x8,%pcrel_hi(PASCALMAIN)
	addi a0, x8, %pcrel_lo(1b)
1:auipc	x8,%pcrel_hi(__libc_csu_init)
	addi a3, x8, %pcrel_lo(1b)

        /* __libc_start_main (main, argc, argv, init, fini, rtld_fini, stack_end) */

        /* Let the libc call main and exit with its return code.  */
1:auipc	x8,%pcrel_hi(__libc_start_main)
        jalr ra, x8, %pcrel_lo(1b)

        /* should never get here....*/
1:auipc	x8,%pcrel_hi(abort)
        jalr ra, x8, %pcrel_lo(1b)

        .globl  _haltproc
        .type   _haltproc,function
_haltproc:
1:auipc	x8,%pcrel_hi(operatingsystem_result)
	lbu	x1,%pcrel_lo(1b)(x8)
	addi	x17, x0, 94
	ecall
        jal x0, _haltproc

        /* Define a symbol for the first piece of initialized data.  */
        .data
        .globl __data_start
__data_start:
        .long 0
        .weak data_start
        data_start = __data_start

.bss
        .comm __stkptr,8

        .comm operatingsystem_parameter_envp,8
        .comm operatingsystem_parameter_argc,4
        .comm operatingsystem_parameter_argv,8

        .section ".comment"
        .byte 0
        .ascii "generated by FPC http://www.freepascal.org\0"

/* We need this stuff to make gdb behave itself, otherwise
   gdb will chokes with SIGILL when trying to debug apps.
*/
        .section ".note.ABI-tag", "a"
        .align 4
        .long 1f - 0f
        .long 3f - 2f
        .long  1
0:      .asciz "GNU"
1:      .align 4
2:      .long 0
        .long 2,0,0
3:      .align 4

.section .note.GNU-stack,"",%progbits
